package demo05;

/*
 * 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
 * */


/*
 *解法思想一览：假如总钱数为（S），面值硬币为【X1，X2，X3】
 *			1.暴力回溯：由于所有的硬币组成了最后找的钱，那么面值为X的硬币个数不会超过总面值S/X；
 *						这对于每个面值的硬币都是一样的，那么就从里面找相加可以得到S的子集，并计算挑选出最小的那个即可
 *          2.动态规划的方法（自顶向下）：假如找到总钱数S所需最小，那么就是找到 S-X（X为零钱中最后一枚面值的硬币）也需要最小
 *          							即，当大问题最优，那么他的子问题也要最优，一直迭代，就可以找出每个子问题的最优解
 *          							再进行相加就可以了，当然，这个过程中，我们需要将每次子问题的计算结果保存一下，防止
 *          							同一个问题计算多次。
 *          3.动态规划的方法（由下及上）：正好是自顶向下的反面，从最小开始，假如之前的问题已经解决了（从0开始一直到S-1，都已经
 *             							计算出最小的次数了），那么，对于金钱S来说，如果他能找的开，那么必定会在之前的子问题
 *                                      中选取一个，然后再加上一枚硬币的值，正好凑齐金钱S，那他的计算结果就是   
 *                                        min((S-X1),(S-X2),(S-X3))+1
 *          4.贪心算法：如果要求次数最少，那么必定是先挑大的来，大的满足了，再挑小的，这样就可以满足了
 *          			但是，贪心算法有一个致命的缺点，就是他算出来的不一定是最优解，例如【1，7，10】 S=14
 *          			则可能是 10+1+1+1+1 但是不及 7+7，所以要对贪心算法进行优化
 *                      如果是【3，7，10】，那么可能无法找出钱 10 + 3 +？ = 14 ，这就是贪心的缺点
 *                      所以要对贪心进行优化，怎么优化呢，无非就是退掉大面额的物品，选取小面额的继续来
 *           5.背包算法也可以解决：
 *           		1.  0-1背包问题：一种硬币只能那一次
 *           		2.  完全背包：一种硬币可以拿无限次
 *           		3.  多重背包：一种硬币只能拿S次（S有限定）
 **/
public class CoinChange {
	
	public static void main(String[] args) {
		int[] coins = {2};		
		System.out.println(coinChange(coins, 3));
	}
	
	public static int coinChange(int[] coins, int amount) {
		int count = 0;
		
		while(amount>0) {
			int max = 0;
			for(int i=0;i<coins.length;i++) {
				if(amount>=coins[i]&&coins[i]>max) {
					max = coins[i];
				}
			}//找到一个最大的
			//假如找不到，那么就找不开了
			if (max==0) {
				return -1;
			}
			amount -= max;
			count++;
			if (amount<0) {
				count = -1;				
			}
		}
		return count;

    }

}
